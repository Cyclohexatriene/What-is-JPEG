# 函数介绍

**本程序依次调用以下所有函数，完成从读取到生成JPEG（不含文件头尾）的全过程。**



- `void load(string path, vector<vector<vector<double>>>& pixels)`

**作用：**用于从指定的路径`path`中读取数据，并将读到的RGB值存入数组`pixels`中。pixels是一个三维double数组，其中前两个维度表示像素点的坐标，第三维用三个double分别储存该像素的RGB参数。

**传入参数：**传入一个以字符串形式保存的路径，以及用于保存数据的pixels数组的引用。

**函数输出：**若生成成功返回0，若生成失败返回-1.



- `void colorSpaceConversion(vector<vector<vector<double>>>& pixels)`

**作用：**用于将读入的RGB数据转换成YCRCb格式。

**传入参数：**传入pixels的引用。

**函数输出：**为了降低重复拷贝数组造成的开销，本函数没有返回值，而是直接在原数组上修改。

**备注：**为了方便后续离散余弦变换，本程序在这个函数里就直接将YCrCb的值各减了128。



- `inline double C(int x) { return x == 0 ? 1 / sqrt(2) : 1; }`
- `void DCT(vector<vector<vector<double>>>& pixels)`

**作用：**对前一个函数处理后的pixels数组进行离散余弦变换。

**传入参数：**传入pixels的引用。

**函数输出：**同上一个函数，直接在原数组上修改，无返回值。

**备注：**为使代码简洁，本程序额外定义了一个内联函数用于计算公式中`C(u)`和`C(v)`的值。



- `void quantify(vector<vector<vector<double>>>& pixels)`

**作用：**进一步处理经离散余弦变换得到的pixels数组，将其与量化矩阵逐项相除并取整。

**传入参数：**传入pixels的引用。

**函数输出：**直接在原数组上修改，无返回值。



- `void zigzag(vector<vector<vector<double>>>& pixels, vector<int>& zigzaged)`

**作用：**将pixels数组以`8*8`的矩阵为单位进行Z字型排列，再将所有`8*8`矩阵从左到右、从上到下地排列。每个像素点都按YCrCb的顺序排列。

**传入参数：**传入pixels的引用，另传入一个名为`zigzaged`的数组的引用，用于保存Z字型排列后的数据流作为函数输出，同样以引用的形式避免了重复拷贝造成的效率浪费。

**函数输出：**直接将数据流写入zigzaged数组，无返回值。



- `void rlEncoding(vector<int>& zigzaged, vector<vector<int>>& rlcode)`

**作用：**将经Z字型排列后的数据进行游程编码。

**传入参数：**Z字型排列后的数组的引用和储存结果的名为`rlcode`的二维数组的引用。

**函数输出：**直接将编码结果写入rlcode数组，无返回值。



- `inline int cntbit(int x)`
- `string getCode(int x)`
- `void vlEncoding(vector<int> vec, vector<vector<int>>& vlcode, vector<string>& str)`

**作用：**对游程编码的结果进行进一步编码，即位数+变长编码。

**传入参数：**游程编码中的一项，以及用于储存结果的`vlcode`数组的引用和`str`数组的引用。

**函数输出：**将变长编码的前两项以十进制数的形式存入vlcode数组，并将编码后的二进制结果以字符串的形式存入str数组。无返回值。

**备注：**为使代码简洁，本程序额外定义了两个函数，其中`cntbit`用于计算某个数经过编码后应该有几个二进制位，`getCode`用于得到某个数的二进制编码并以字符串形式返回。



- `void huffmanEncoding(vector<vector<int>>& vlCode, vector<string>& codestr, string& body)`

**作用：**对变长编码后的数组进行huffman编码。

**传入参数：**传入vlCode和codestr两个数组的引用。

**函数输出：**直接将编码后的结果以二进制字符串的形式存入字符串`body`，无返回值。

**备注：**函数中内置了四张Huffman编码表。从题目给的链接中复制下来的。



- `void generate(string path, string binary)`

**作用：**在指定的路径`path`将输入的二进制字符串生成为JPEG文件。

**传入参数：**传入路径`path`和二进制字符串`binary`。

**函数输出：**若生成成功返回0，若生成失败返回-1.

# 参考资料

https://zhuanlan.zhihu.com/p/72044095

通过阅读这篇文章，我对范式Huffman编码的方式有了一个初步的认识，大致了解了编码的流程，也思考了一些实现的具体算法。

https://blog.csdn.net/emily2ly/article/details/83697047
一开始以为Huffman编码要自己算，就按照这篇博客多写了几个函数，通过优先队列建哈夫曼树，再利用广度优先搜索得到原始数据对应的编码需要的二进制位数。然后当我思考应该如何分配编码和存图的时候发现文档中给了JPEG推荐的Huffman编码表，于是直接内置进了代码中。

https://blog.csdn.net/ryfdizuo/article/details/41250775

https://www.cnblogs.com/lakeone/p/3596996.html

本来想试着把文件头尾也加上的，但是简单浏览这两篇博客之后发现时间上来说不太允许我彻底理解并实现文件头的编码，遂放弃。疑点在于我直接暴力内置Huffman的编码表，而不知道该以何种顺序、何种编码方式把四张Huffman编码表写进文件头里。

# 总结与反思

1. 你觉得解决这个任务的过程有意思吗？

我觉得完成任务的过程是痛并快乐着的吧。因为要整体构思一段长代码的结构、所选择的数据结构，以及写到后面发现换另一种数据结构更方便，需要回过头来重新修改写好的代码...但是一步一脚印地完成文档中的Task，并且可以看到数据在自己代码的处理下一步步变得整齐，最后化为一串二进制的码，还是很有成就感的！（虽然最后并没有看到图图）

2. 你在网上找到了哪些资料供你学习？你觉得去哪里/用什么方式搜索可以比较有效的获得自己想要的资料？

我所参考的资料已经在上面列出了。平时我在搜索资料时会直接使用搜索引擎，优先使用bing，如果bing搜不到满意的结果会再去百度尝试一下。如果是语法方面的问题，我比较爱看菜鸟教程；其他问题我会更倾向于查看CSDN、博客园和知乎专栏等前人总结的经验。

3. 在过程中，你遇到最大的困难是什么？你是怎么解决的？

文档好多信息给的并不详细，模棱两可。我的解决方案是先在心里进行一个假设，再代入下文看看是否make sense。我的问题都挺具体的（详情可以看看后面的碎碎念部分），上网搜索得到的大多是更粗粒度的介绍或记录，一步到位的保姆式教程是少有的，所以我需要在阅读一些相关的资料之后结合自己的合理推测来“暂时”解决问题，最后还需要在实践中验证我的推测。

4. 完成任务之后，再回去阅读你写下的代码和文档，有没有看不懂的地方？如果再过一年，你觉得那时你还可
   以看懂你的代码吗？

我觉得我的代码还是很懂的，而且结构清晰，一个函数实现一个功能，然后逐个调用实现整个程序的功能，而且除了完全没必要的地方以外基本都留了注释，我还是很有信心一年后能看懂自己的代码的。

5. 其他想说的想法或者建议。

可以看看下面的后记~不过基本都是些没啥营养的碎碎念，如果赶时间的话也可以直接pass

# 后记（碎碎念）

第一次写这么大的项目，周末连着肝了两天，总共耗时应该有10个小时以上，有几次对文档内容理解不够全面导致做了无用功，这部分代码我没有删去，而是以注释的形式留在了源代码文件里。对我来说，代码的编写只是第二大的困难，但最后经过整理，我的`main()`函数连注释带空行也只有60余行，JPEG压缩的一系列步骤我都以独立函数的形式编写，也就是我所理解的“模块化”编程，这样只看`main()`函数就可以对我程序的整体结构有一个宏观的把握。同时在代码的编写过程中我也第一次实际使用了IDE的“断点“的功能。因为以前写的代码都比较短，只需要从头开始逐行运行就可以起到调试的作用，而在长代码中不使用断点就根本没法调试。而最大的困难在于理解文档给出的信息。比如离散余弦变换一步，作为对数学非常恐惧的菜鸟，看到这一长串公示两眼就发蒙，不过硬着头皮猜测了一下`u/v/i/j`分别表示什么，并结合上下文得到印证之后也算是成功编写出了代码；文档的后半段好多地方写的比较模棱两可，比如zigzag排列时是在`8*8`的范围内排列还是整个`256*256`的范围排列，还有就是范式Huffman编码如何进行实际操作等，前者通过联系上下文可以得到答案，而后者则必须要自己主动去查询一些信息了。虽然经历了一些曲折，但也自认为顺利完成了这一部分代码的编写。



